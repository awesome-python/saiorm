Welcome to saiorm /saɪɔ:m/,塞翁
===============================

Saiorm is a simple lightweight library for accessing database.It will take you have a easy way to use SQL database.

Only translate the params to SQL statements.Implements translation of relatively simple SQL statement.

Support MySQL PostgreSQL and SQL Server.you can inherit from saiorm.base.ChainDB to support other
types of database with the same API,like siaorm.PostgreSQL.ChainDB.

Saiorm require pymysql pymssql psycopg2 for each database type.

**Method:**

- Method **insert, select, update, delete, execute, executemany, increase, decrease** should be executed **finally**,they will take effect immediately.

- Method **last_sql** return the latest executed sql.

- Method **get_fields_name** get a list of all fields name, cache them by default.

- Method **where** receive dict or str type. **IN** require a string or a sequence with str.

- Method **select** and **get** return data only.

- Method **update**, **delete**, **execute** return a dict,including lastrowid, rowcount, rownumber, sql.

- Use various method **join**,should use string for method join and method where.

**ATTENTION**

- Saiorm does not convert value type in native functions and IN and other condition(eg.limit,order_by,group_by,various join).If you want to use the values passed from user,you must check them,because it's easily to triggering injection vulnerability.

- You can add **`** as a prefix to set the field to native function in method select and update etc.

- The latest sql **SQL Server** returns is empty string by default,if you want to get it,please pass **return_sql=True** when call **connect**,because pymmsql do not return it, it's generated by saiorm.

Initialization
~~~~~~~~~~~~~~

saiorm.init() use MySQL by default,you could set database type by param **driver** explicitly.

If use **SQL Server**,you should pass **primary_key** to method table,because SQL Server do not support limit,we will use primary_key to implement method limit.

use MySQL:

.. code:: python

    import saiorm

    DB = saiorm.init()  # without table name prefix
    # DB = saiorm.init(table_name_prefix="abc_") # mysql with table name prefix
    DB.connect({"host": "", "port": 3306, "database": "", "user": "", "password": ""})
    table = DB.table("xxx")

use PostgreSQL:

.. code:: python

    DB = saiorm.init(driver="PostgreSQL")   # without table name prefix
    # DB = saiorm.init(driver="PostgreSQL", table_name_prefix="abc_") # with table name prefix
    DB.connect({"host": "", "port": "5432", "database": "", "user": "", "password": ""})
    table = DB.table("xxx")

use SQL Server(has some difference):

.. code:: python

    DB = saiorm.init(driver="SQLServer")   # without table name prefix
    # DB = saiorm.init(driver="SQLServer", table_name_prefix="abc_") # with table name prefix
    DB.connect({"host": "", "port": "1433", "database": "", "user": "", "password": ""})
    # DB.connect({"host": "", "port": "1433", "database": "", "user": "", "password": ""}, return_sql=True)# can get latest sql you executed
    table = DB.table("xxx", primary_key="id")  # For LIMIT implement with SQL Server

**The SQL in usages following is MySQL style,it's a little different from PostgreSQL and SQL Server, especially LIMIT.**

Usage for calling native function only
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    DB.select("`NOW()")
    DB.select("`SUM(1+2)")

will be transformed to SQL:

.. code:: sql

    SELECT NOW();
    SELECT SUM(1+2);

Usage for select and get
~~~~~~~~~~~~~~~~~~~~~~~~~

- select and get receive a fields param.

- select will return all data.

- get will overwrite method limit automatically,then return the latest line only.

.. code:: python

    # select all fields
    table.select()

    # get the latest line
    table.order_by("id DESC").get()

    # kinds of params in where
    table.where({
        "a": 1,
        "b": ("BETWEEN", "1", "2"),
        "c": ("`ABS(?)", "2"),
        "d": ("!=", 0),
        "e": ("IN", "1,2,3"),
        "f": "`NOW()",
    }).select("e,f")

will be transformed to SQL:

.. code:: sql

    SELECT * FROM xxx ;
    SELECT * FROM xxx  ORDER BY id DESC LIMIT 1;
    SELECT e,f FROM xxx WHERE a=1 AND b BETWEEN '1' AND '2' AND c=ABS(2) AND d!=0 AND e IN (1,2,3) AND f=NOW() ;

Usage for update
~~~~~~~~~~~~~~~~

If you want use native function,you can pass a tuple.

.. code:: python

    table.where({
        "a": ("IN", ["1", "2", "3"]),
        "b": ("`ABS(?)", "2"),
    }).update({
        "c": "`ABS(2)",
        "d": ("`ABS(?)", 3),
        "e": "2",
    })

will be transformed to SQL:

.. code:: sql

    UPDATE xxx SET c=ABS(2),d=ABS(3),e='2' WHERE a IN (1,2,3) AND b=ABS(2) ;


Usage for insert
~~~~~~~~~~~~~~~~

insert function support two kinds of data

.. code:: python

    # use natural dict
    table.insert({
        "a": "1",
        "b": "2",
    })

    # use split dict
    table.insert({
        "fields": ["a", "b"],
        "values": ["1", "2"],
    })

    # use natural dict in list, SQL will in one line
    table.insert_many([{
        "a": "1",
        "b": "2",
    }, {
        "a": "3",
        "b": "4",
    }, {
        "a": "5",
        "b": "6",
    }])

    # use split dict in list, SQL will in one line
    table.insert_many({
        "fields": ["a", "b"],
        "values": [
            ["1", "2"],
            ["3", "4"],
            ["5", "6"]
        ]
    })


will be transformed to SQL:

.. code:: sql

    INSERT INTO xxx (a,b) VALUES ('1','2');
    INSERT INTO xxx (a,b) VALUES ('1','2');
    INSERT INTO xxx (a,b) VALUES ('1','2'),('3','4'),('5','6');
    INSERT INTO xxx (a,b) VALUES ('1','2'),('3','4'),('5','6');

If pass split dict to insert or insert_many,fields is not necessary,
if the dict has values only,it will insert by the order of table struct.

Usage for delete
~~~~~~~~~~~~~~~~

By default, **delete** must have **where** condition,or you can pass strict=False when initialization.

.. code:: python

    table.where({
        "a": "1",
        "b": "2",
        "c": ("`ABS(?)", "2"),
    }).delete()

    table.delete()  # will not be executed, or set strict=False when initialization

will be transformed to SQL:

.. code:: sql

    DELETE FROM xxx WHERE a='1' AND b='2' AND c=ABS(2) ;
    DELETE FROM xxx ;

Usage for increase
~~~~~~~~~~~~~~~~~~

Numerical field increase

.. code:: python

    table.increase("a", 1)

will be transformed to SQL:

.. code:: sql

    UPDATE xxx SET a=a+1

Usage for decrease
~~~~~~~~~~~~~~~~~~

Numerical field decrease

.. code:: python

    table.decrease("a", 1)

will be transformed to SQL:

.. code:: sql

    UPDATE xxx SET a=a-1

Method limit
~~~~~~~~~~~~

basic usage:

.. code:: python

    table.limit(number)

with offset:

.. code:: python

    table.limit(offset, number)

Method where
~~~~~~~~~~~~

.. code:: python

    table.where({
        "a": 1,
        "b": ("BETWEEN", "1", "2"),
        "c": ("`ABS(?)", "2"),
        "d": ("!=", 0),
        "e": ("IN", "1,2,3"),
        "f": "`NOW()",
    }).select("e,f")

- must check param to prevent injection vulnerabilities.

- when calling native mysql function the param placeholder could be ?.

- condition will be equals to value,or pass a tuple or list, and set the first item to change it.

- use IN or BETWEEN should pass a tuple or list.

- pass string type is allowed,you should join param into this string.

Method shorthands
~~~~~~~~~~~~~~~~

| t equals to table
| w equals to where
| ob equals to order_by
| l equals to limit
| gb equals to group_by
| j equals to join
| ij equals to inner_join
| lj equals to left_join
| rj equals to right_join
| s equals to select
| i equals to insert
| im equals to insert_many
| u equals to update
| d equals to delete
| inc equals to increase
| dec equals to decrease